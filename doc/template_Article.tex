\documentclass[]{article}
\usepackage[main=english,french]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{enumitem}  
\usepackage{listings}
\usepackage{arydshln}
\usepackage{amsmath}
%opening
\title{Stationary and non-stationary sinusoidal model synthesis with phase vocoder and FFT$^{-1}$}
\author{Cl\'ement Cazorla, Vincent Chrun, Bastien Fundaro, Cl\'ement Maliet \\ENSEEIHT - 3EN TSI 2016-2017}


\begin{document}

\maketitle

\begin{abstract}
The present document is to serve as both a technical report and a documentation for the code produced during the long project. As such the first part will explain the theoretical framework and the state-of-the-art of the field. The second part will give some insight about the code structure and the conventions that were adopted and last but not least, the third part will serve as an actual documentation and details every class, methods and attributes.
\end{abstract}
\newpage
\tableofcontents


\newpage
\part{Theoretical framework}\label{sec:theoretical-framework}
\section{Sound synthesis}\label{sec:sound-synthesis}
\subsection{Frequency domain}\label{sec:frequency-domain}
\subsection{Sinusoidal model}\label{sec:sinusoidal-model}
\subsection{Phase Vocoder}\label{sec:phase-vocoder}
\section{Theoretical synthesis with phase vocoder and FFT$^{-1}$}\label{sec:theoretical-synthesis-with-phase-vocoder-and-fft-1}
\subsection{Stationary case}\label{sec:stationary-case}
\subsection{Non-stationary case}\label{sec:non-stationary-case}


\newpage
\part{Code structure and conventions}\label{sec:code-structure-and-conventions}

\section{Conventions}\label{sec:conventions}

In this section we remind the reader of a few coding convention necessary to ensure a seamless work flow and a bug free program as much as possible.
Files should contains an entire module (as described in \ref{sec:general-structure}) not just a single class to limit the number of files and ease the bug tracking.
Imports in files should be kept to a minimum and left in namespaces (do not use the \lstinline[columns=fixed,language=Python]|from module import *| syntax). It is preferable to import a whole module if more than three elements from the module are needed in the file, otherwise consider the \lstinline[columns=fixed,language=Python]|from module import element1, element2| syntax to avoid unnecessary memory flooding. If conflicts exists, notwithstanding the number of elements needed, the whole modules are to be loaded with a namespace.
Namespaces may be abbreviated to the programmer's convenience however some abbreviation are to be universally respected :
\begin{enumerate}[label=(\roman*)]
	\item \texttt{numpy} should always be imported as \texttt{np}
	\item \texttt{matplotlib.pyplot} should always be imported as \texttt{plt}
\end{enumerate}

Finally math functions should always come from the numpy module and not python's math module to guarantee a universal behaviour across the program.

\subsection{Naming conventions}\label{sec:naming-conventions}

Naming conventions are freely adapted from Python recommended conventions defined in PEP8 \cite{pep8}, as such :
\begin{enumerate}[label=(\roman*)]
	\item \emph{Class} should be named in \texttt{CapitalizedWord}
	\item \emph{Methods} and \emph{functions} should be named in \texttt{lower\_case\_with\_underscores}
	\item \emph{Attributes} and \emph{variables} should be names in \texttt{lower\_case\_with\_underscores}
	\item \emph{Instantiation} following the fact that everything is an object in python should be named as \emph{variables}.
\end{enumerate}
Moreover during class declaration, the following principles should be adopted :
\begin{enumerate}[label=(\roman*)]
	\item Non-public methods and attributes should use one leading underscore.
	\item Elements that conflicts with python reserved name should use one trailing underscore rather that simplification or a misspelling.
	\item Accessors or mutators using one leading underscore should be interpreted as properties of their associated attribute. As such it should be guaranteed that they induce a low computational cost.
	\item Non-public elements that should not be inherited or may cause conflicts during inheritance should use two leading underscore and make use of Python name-mangling.
\end{enumerate}
To seamlessly manipulate both \emph{stationary} and \emph{non stationary} models, class that are inherited in two versions are preceded with either \texttt{Stationary} are \texttt{NonStationary} respectively.
\subsection{Spectrum and sinusoids parameters classes}\label{sec:spectrums-and-sinusoids-parameters}
Because many spectra, main lobes and sinusoidal model parameters have to be traded between modules we created two classes, respectively \texttt{Spectrum} and \texttt{Parameters}. They mainly serve as containers, holding the data and returning them in a point wise fashion.
This way we can prevent conflicts and errors that would come from a non-uniform data sharing protocol and as well ensure that every operation performed on either spectra or parameters are made following the same principles and algorithms.
\subsubsection{Spectrum}
\texttt{%
\begin{tabular}{|lc|}
	\hline
	Spectrum & \\
	\hline
	\hline
	\_amplitude : np.array & \\
	\_phase : np.array  & \\
	\_nfft : int  & \\
	\hdashline
	\_\_init\_\_(self, amplitude, phase) & \\
	\_\_add\_\_(self, other) & \\
	\_\_iadd\_\_(self, other) & \\
	\_\_mul\_\_(self, other) & \\
	\_\_imul\_\_(self, other) & \\
	from\_complex\_spectrum(cls, complex\_spectrum) & @classmethod\\
	void\_spectrum(cls) & @classmethod\\
	set\_spectrum(self, amplitude, phase, & \\ \hspace{10mm} start\_bin=None, stop\_bin=None) & \\
	set\_complex\_spectrum(self, complex\_spectrum, & \\ \hspace{10mm} start\_bin=None, stop\_bin=None) & \\
	get\_amplitude(self, k) & \\
	get\_phase(self, k) & \\
	get\_nfft(self) & \\
	\hline
\end{tabular}} \medskip\newline
The Spectrum class stores a spectrum in amplitude and phase, however it may be created or changed from a complex \texttt{np.array} respectively with the class method \texttt{from\_complex\_spectrum} and the method \texttt{set\_complex\_spectrum}. Those two methods may take optional parameters start\_bin and stop\_bin if one need to update only a part of the spectrum, for example a single lobe. The class checks that the given data are consistent upon instantiation.
The $+$ operation as well as the $+=$ operation have been defined between two \texttt{Spectrum} objects and between a \texttt{Spectrum} object and an array of complex numbers.\\
The $\times$ operation as well as the $\times=$ operation have been defined between a \texttt{Spectrum} object and an array of complex numbers.
Addition and multiplication attempts between other data type will result in a \texttt{NotImplementedError} exception.
\subsubsection{Parameters}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		Parameters & \\
		\hline
		\hline
		\_amplitudes : np.array & \\
		\_frequencies : np.array & \\
		\_phases : np.array  & \\
		\_number\_sinuses : int  & \\
		\hdashline
		\_\_init\_\_(self, amplitudes, frequencies, phases) & \\
		get\_amplitude(self, k) & \\
		get\_frequency(self, k) & \\
		get\_phase(self, k) & \\
		get\_number\_sinuses(self) & \\
		\hline
\end{tabular}} \medskip\newline
The Parameters class is more of a structure than a class and only contains the stationary sinusoidal model parameters and their respective accessors. It also stores the number of sinuses and checks that the given data are consistent upon instantiation.\\
In the stationary sinusoidal model the signal $s(t)$ is defined as follow\footnotemark[1] :
\begin{equation*}
	s(n) = \sum_{i=1}^{N_{sinus}} \alpha_i \sin(2\pi \bar{f_i} n+ \phi_i)
\end{equation*}
with $\bar{f_i} = \frac{f_i}{f_s}$ the normalised frequency.\\
We then store the parameters as follows :
\begin{description}
	\item[\_amplitudes] stores the $\alpha_i$
	\item[\_frequencies] stores the $\bar{f_i}$
	\item[\_phases] stores the $\phi_i$
\end{description}
\subsubsection{NonStationaryParameters}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		NonStationaryParameters(Parameters) & \\
		\hline
		\hline
		\_acrs : np.array & \\
		\_fcrs : np.array & \\
		\hdashline
		\_\_init\_\_(self, amplitudes, frequencies, phases, acrs, fcrs) & \\
		get\_acr(self, k) & \\
		get\_fcr(self, k) & \\
		\hline
\end{tabular}} \medskip\newline
The stationary sinusoidal model can be extended to the first order development to better model fast amplitude and frequency change over time. The signal $s(t)$ can then be expressed as a sum of linearly varying chirps\footnotemark[1] :
\begin{equation*}
	s(n) = \sum_{i=1}^{N_sinus} (\alpha_i + \mu_i \cdot nT_s) \sin(2\pi \bar{f_i} n + \frac{\psi_i}{2} (nT_s)^2 + \phi_i)
\end{equation*}
Where we define the \textbf{Amplitude Change Rate} $\mu$ and the \textbf{Frequency Change Rate} $\psi$. \\
Thus we inherit the \texttt{Parameters} class to add the two additional parameters as follow :
\begin{description}
	\item[\_acrs] stores the $\mu_i$
	\item[\_fcrs] stores the $\psi_i$
\end{description}
\footnotetext[1]{Please look up section \ref{sec:sinusoidal-model} page \pageref{sec:sinusoidal-model} for more details}
\section{Code structure}\label{sec:code-structure}
\subsection{General structure}\label{sec:general-structure}
\subsection{Class structure}\label{sec:class-structure}


\newpage
\part{Documentation}\label{sec:documentation}
\section{Core module}
\subsection{Synthesizer}
\subsection{StationarySynthesizer}
\subsection{NonStationarySynthesizer}
\section{Spectrum generation module}\label{sec:spectrum-generation-module}
\subsection{SpectrumGenerator}\label{sec:spectrumgenerator}
\subsection{StaionarySpectrumGenerator}\label{sec:staionaryspectrumgenerator}
\subsection{NonStationarySpectrumGenerator}\label{sec:nonstationaryspectrumgenerator}
\subsection{StationnaryLobe}\label{sec:stationnarylobe}
\subsection{NonStationaryLUT}\label{sec:nonstationarylut}
\section{Phase Vocoder module}\label{sec:phase-vocoder-module}
\subsection{PhaseVocoder}\label{sec:phasevocoder}
\subsection{StationaryPhaseVocoder}\label{sec:stationaryphasevocoder}
\subsection{NonStationaryPhaseVocoder}\label{sec:nonstationaryphasevocoder}

\newpage
\section*{Conclusion}

\newpage
\bibliographystyle{unsrt}
\bibliography{biblio}
\end{document}
