\documentclass[]{article}
\usepackage[main=english,french]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{enumitem}  
\usepackage{listings}
\usepackage{arydshln}
\usepackage{amsmath}
\usepackage{cases}  
\usepackage{cite}
\usepackage{graphicx}
\usepackage{dsfont}
\usepackage{float}
 \graphicspath{{images/}}
%opening
\title{Stationary and non-stationary sinusoidal model synthesis with phase vocoder and FFT$^{-1}$}
\author{Cl\'ement Cazorla, Vincent Chrun, Bastien Fundaro, Cl\'ement Maliet \\ENSEEIHT - 3EN TSI 2016-2017}


\begin{document}

\maketitle

\begin{abstract}
The present document is to serve as both a technical report and a documentation for the code produced during the long project. As such the first part will explain the theoretical framework and the state-of-the-art of the field. The second part will give some insight about the code structure and the conventions that were adopted and last but not least, the third part will serve as an actual documentation and details every class, methods and attributes.
\end{abstract}
\newpage
\tableofcontents


\newpage
\part{Introduction}\label{sec:introduction}

\section{The company}\label{sec:the-company}
\section{Objective}\label{sec:objective}
\section{Context of the project}\label{sec:context-of-the-project}
\section{Work environment and project management}\label{sec:work-environment-and-project-management}

\newpage
\part{Method Overview}\label{part:method-overview}
\section{Additive Synthesis (Time Domain)}\label{sec:additive-synthesis-(time-domain)}
\section{Method Overview}\label{sec:method-overview}

\newpage
\part{The additive synthesis in frequency domain}

\section{Stationary Case}\label{stationary-case}
\subsection{Phase Coherence}\label{stationary-case}
The phase becomes a problem when we are synthesizing a signal, even a simple sinusoid, because for each frame we create a "different" sinusoid with the same parameters. That is not what we want, we want to create a single sinusoid : 
	\begin{figure} [H]
	\centering
	\includegraphics[scale = 0.2]{coherentphase.png}
	\caption {Coherent phase (above) vs. Incoherent phase (below) between frames}
	\end{figure}
 When we listen to a signal which phase is incoherent between frames (vertical jump) it will sound as "pops".  This is something very unpleasant to listen to. We need to do something to make sure there is no discontinuity. Thus, correcting the phase is absolutely necessary. \\
In the stationary case, it is something easy to do. Knowing the exact frequency and for each frame, we advance the phase of $2\pi \tilde{f} R_a$. To see details of the theoretical phase advance for the stationary case, please refer to the appendix (\ref{theoretical_phase_advance}).
\section{Quasi-Stationary Case}\label{quasi-stationary-case}
\subsection{Theory}\label{theory-quasi-stat}
\subsection{phase vocoder}\label{phase-vocoder-quasi-stationary}
\section{Non-Stationary Case}\label{non-stationary-case}
\subsection{Theory}\label{theory-non-stat}
\subsection{phase vocoder}\label{phase-vocoder-stationary}

\newpage
\part{Result}
\section{Sationary Case}\label{sec:sationary-results}
\section{Non-Stationary Case}\label{non-stationary-results}

\newpage
\part{Code structure and conventions}\label{sec:code-structure-and-conventions}

\section{Conventions}\label{sec:conventions}

In this section we remind the reader of a few coding convention necessary to ensure a seamless work flow and a bug free program as much as possible.
Files should contains an entire module (as described in \ref{sec:general-structure}) not just a single class to limit the number of files and ease the bug tracking.
Imports in files should be kept to a minimum and left in namespaces (do not use the \lstinline[columns=fixed,language=Python]|from module import *| syntax). It is preferable to import a whole module if more than three elements from the module are needed in the file, otherwise consider the \lstinline[columns=fixed,language=Python]|from module import element1, element2| syntax to avoid unnecessary memory flooding. If conflicts exists, notwithstanding the number of elements needed, the whole modules are to be loaded with a namespace.
Namespaces may be abbreviated to the programmer's convenience however some abbreviation are to be universally respected :
\begin{enumerate}[label=(\roman*)]
	\item \texttt{numpy} should always be imported as \texttt{np}
	\item \texttt{matplotlib.pyplot} should always be imported as \texttt{plt}
\end{enumerate}

Finally math functions should always come from the numpy module and not python's math module to guarantee a universal behaviour across the program.

\subsection{Naming conventions}\label{sec:naming-conventions}

Naming conventions are freely adapted from Python recommended conventions defined in PEP8 \cite{pep8}, as such :
\begin{enumerate}[label=(\roman*)]
	\item \emph{Class} should be named in \texttt{CapitalizedWord}
	\item \emph{Methods} and \emph{functions} should be named in \texttt{lower\_case\_with\_underscores}
	\item \emph{Attributes} and \emph{variables} should be names in \texttt{lower\_case\_with\_underscores}
	\item \emph{Instantiation} following the fact that everything is an object in python should be named as \emph{variables}.
\end{enumerate}
Moreover during class declaration, the following principles should be adopted :
\begin{enumerate}[label=(\roman*)]
	\item Non-public methods and attributes should use one leading underscore.
	\item Elements that conflicts with python reserved name should use one trailing underscore rather that simplification or a misspelling.
	\item Accessors or mutators using one leading underscore should be interpreted as properties of their associated attribute. As such it should be guaranteed that they induce a low computational cost.
	\item Non-public elements that should not be inherited or may cause conflicts during inheritance should use two leading underscore and make use of Python name-mangling.
\end{enumerate}
To seamlessly manipulate both \emph{stationary} and \emph{non stationary} models, class that are inherited in two versions are preceded with either \texttt{Stationary} are \texttt{NonStationary} respectively.
\subsection{Spectrum and sinusoids parameters classes}\label{sec:spectrums-and-sinusoids-parameters}
Because many spectra, main lobes and sinusoidal model parameters have to be traded between modules we created two classes, respectively \texttt{Spectrum} and \texttt{Parameters}. They mainly serve as containers, holding the data and returning them in a point wise fashion.
This way we can prevent conflicts and errors that would come from a non-uniform data sharing protocol and as well ensure that every operation performed on either spectra or parameters are made following the same principles and algorithms.
\subsubsection{Spectrum}
\texttt{%
\begin{tabular}{|lc|}
	\hline
	Spectrum & \\
	\hline
	\hline
	\_amplitude : np.array & \\
	\_phase : np.array  & \\
	\_nfft : int  & \\
	\hdashline
	\_\_init\_\_(self, amplitude, phase) & \\
	\_\_add\_\_(self, other) & \\
	\_\_iadd\_\_(self, other) & \\
	\_\_mul\_\_(self, other) & \\
	\_\_imul\_\_(self, other) & \\
	from\_complex\_spectrum(cls, complex\_spectrum) & @classmethod\\
	void\_spectrum(cls) & @classmethod\\
	set\_spectrum(self, amplitude, phase, & \\ \hspace{10mm} start\_bin=None, stop\_bin=None) & \\
	set\_complex\_spectrum(self, complex\_spectrum, & \\ \hspace{10mm} start\_bin=None, stop\_bin=None) & \\
	get\_amplitude(self, k) & \\
	get\_phase(self, k) & \\
	get\_nfft(self) & \\
	\hline
\end{tabular}} \medskip\newline
The Spectrum class stores a spectrum in amplitude and phase, however it may be created or changed from a complex \texttt{np.array} respectively with the class method \texttt{from\_complex\_spectrum} and the method \texttt{set\_complex\_spectrum}. Those two methods may take optional parameters start\_bin and stop\_bin if one need to update only a part of the spectrum, for example a single lobe. The class checks that the given data are consistent upon instantiation.
The $+$ operation as well as the $+=$ operation have been defined between two \texttt{Spectrum} objects and between a \texttt{Spectrum} object and an array of complex numbers.\\
The $\times$ operation as well as the $\times=$ operation have been defined between a \texttt{Spectrum} object and an array of complex numbers.
Addition and multiplication attempts between other data type will result in a \texttt{NotImplementedError} exception.
\subsubsection{Parameters}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		Parameters & \\
		\hline
		\hline
		\_amplitudes : np.array & \\
		\_frequencies : np.array & \\
		\_phases : np.array  & \\
		\_number\_sinuses : int  & \\
		\hdashline
		\_\_init\_\_(self, amplitudes, frequencies, phases) & \\
		get\_amplitude(self, k) & \\
		get\_frequency(self, k) & \\
		get\_phase(self, k) & \\
		get\_number\_sinuses(self) & \\
		\hline
\end{tabular}} \medskip\newline
The Parameters class is more of a structure than a class and only contains the stationary sinusoidal model parameters and their respective accessors. It also stores the number of sinuses and checks that the given data are consistent upon instantiation.\\
In the stationary sinusoidal model the signal $s(t)$ is defined as follow\footnotemark[1] :
\begin{equation*}
	s(n) = \sum_{i=1}^{N_{sinus}} \alpha_i \sin(2\pi \tilde{f_i} n+ \phi_i)
\end{equation*}
with $\tilde{f_i} = \frac{f_i}{f_s}$ the normalised frequency.\\
We then store the parameters as follows :
\begin{description}
	\item[\_amplitudes] stores the $\alpha_i$
	\item[\_frequencies] stores the $\tilde{f_i}$
	\item[\_phases] stores the $\phi_i$
\end{description}
\subsubsection{NonStationaryParameters}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		NonStationaryParameters(Parameters) & \\
		\hline
		\hline
		\_acrs : np.array & \\
		\_fcrs : np.array & \\
		\hdashline
		\_\_init\_\_(self, amplitudes, frequencies, phases, acrs, fcrs) & \\
		get\_acr(self, k) & \\
		get\_fcr(self, k) & \\
		\hline
\end{tabular}} \medskip\newline
The stationary sinusoidal model can be extended to the first order development to better model fast amplitude and frequency change over time. The signal $s(t)$ can then be expressed as a sum of linearly varying chirps\footnotemark[1] :
\begin{equation*}
	s(n) = \sum_{i=1}^{N_sinus} (\alpha_i + \mu_i \cdot nT_s) \sin(2\pi \tilde{f_i} n + \frac{\psi_i}{2} (nT_s)^2 + \phi_i)
\end{equation*}
Where we define the \textbf{Amplitude Change Rate} $\mu$ and the \textbf{Frequency Change Rate} $\psi$. \\
Thus we inherit the \texttt{Parameters} class to add the two additional parameters as follow :
\begin{description}
	\item[\_acrs] stores the $\mu_i$
	\item[\_fcrs] stores the $\psi_i$
\end{description}
\footnotetext[1]{Please look up section \ref{non-stationary-case} page \pageref{non-stationary-case} for more details}
\section{Code structure}\label{sec:code-structure}
\subsection{General structure}\label{sec:general-structure}
\subsection{Class structure}\label{sec:class-structure}


\newpage
\part{Documentation}\label{sec:documentation}
\section{Core module}
\subsection{Synthesizer}
\subsection{StationarySynthesizer}
\subsection{NonStationarySynthesizer}
\section{Spectrum generation module}\label{sec:spectrum-generation-module}
\subsection{SpectrumGenerator}\label{sec:spectrumgenerator}

\texttt{%
	\begin{tabular}{|lc|}
		\hline
		SpectrumGenerator & \\
		\hline
		\hline
		\_parameters : np.array & \\
		\_nfft : np.float & \\
		\_spectrum : np.array & \\
		\_window\_size : np.float & \\
		\_analysis\_hop : np.float & \\
		\hdashline
		\_\_init\_\_(self, window\_size, parameters, nfft, analysis\_hop)&\\
		\_add\_lobe(self, k, lobe) & \\
		\_set\_window\_size(self, window\_size) & \\
		\_set\_window\_type(self, window\_type) & \\
		\_get\_parameters(self, new\_parameters) & \\
		\_get\_spectrum(self) & \\
		\hline
\end{tabular}} \medskip\newline


 
The aim of this class is to generate a synthetic spectrum from known parameters (amplitudes, phases, frequencies). This class is divided into two subclasses that generate stationary and non-stationary spectrums.\\

\subsection{StationarySpectrumGenerator}\label{sec:staionaryspectrumgenerator}

\texttt{%
	\begin{tabular}{|lc|}
		\hline
		StationarySpectrumGenerator (SpectrumGenerator) & \\
		\hline
		\hline
		\_parameters : np.array & \\
		\_nfft : np.float & \\
		\_spectrum : np.array & \\
		\_window\_size : np.float & \\
		\_analysis\_hop : np.float & \\
		\_lobe\_generator : np.array & \\
		\hdashline
		\_\_init\_\_(self, window\_size, parameters, nfft, analysis\_hop)&\\
		\_add\_lobe(self, k, lobe) & \\
		\hline
\end{tabular}} \medskip\newline


\subsection{NonStationarySpectrumGenerator}\label{sec:nonstationaryspectrumgenerator}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		NonStationarySpectrumGenerator (SpectrumGenerator) & \\
		\hline
		\hline
		\_parameters : np.array & \\
		\_nfft : np.float & \\
		\_spectrum : np.array & \\
		\_window\_size : np.float & \\
		\_analysis\_hop : np.float & \\
		\_lobe\_generator : np.array & \\
		\_regular\_lut : np.array & \\
		\hdashline
		\_\_init\_\_(self, window\_size, parameters, nfft, analysis\_hop)&\\
		\_add\_lobe(self, k) & \\
		\hline
\end{tabular}} \medskip\newline

This class has not been made yet, but the goal is the same as for the StationarySpectrumGenerator.
\subsection{LobeGenerator}\label{sec:lobegenerator}

\texttt{%
	\begin{tabular}{|lc|}
		\hline
		LobeGenerator & \\
		\hline
		\hline
		\_window\_type : np.float & \\
		\_window\_size : np.float & \\
		\_nfft : np.float & \\
		\_window : np.array &\\
		\_lobe : np.array & \\
		\hdashline
		\_\_init\_\_(self, window\_type, window\_size, nfft) &\\
		\_set\_window\_size(self, window\_size) & \\
		\_set\_window\_type(self, window\_type) & \\
		\_gen\_lobe(self) & \\
		\_get\_lobe & \\
		\hline
\end{tabular}} \medskip\newline
This class generates a 11 points main lobe.

\subsubsection{StationnaryLobeGenerator}\label{sec:stationnarylobegenerator}

\texttt{%
	\begin{tabular}{|lc|}
		\hline
		StationaryLobeGenerator(LobeGenerator) & \\
		\hline
		\hline
		\_window\_type : np.float & \\
		\_window\_size : np.float & \\
		\_nfft : np.float & \\
		\_window : np.array &\\
		\_lobe : np.array & \\
		\_gen\_lobe : np.array & \\
		\hdashline
		\_\_init\_\_(self, window\_type, window\_size, nfft) &\\
		\_gen\_lobe(self) & \\
		\hline
\end{tabular}} \medskip\newline

\subsubsection{NonStationaryLobeGenerator}\label{sec:nonstationarylobegenerator}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		NonStationaryLobeGenerator(LobeGenerator) & \\
		\hline
		\hline
		\_abscisse : np.array & \\
		\_ordonnee : np.array & \\
		\_interpolated\_lobe : np.array & \\
		\_regular\_grid : np.array & \\
		\_domain : np.array & \\
		\_number\_acr : np.float & \\
		\_number\_fcr : np.float & \\
		\_number\_points : np.float & \\
		\_LUT : np.array & \\
		\_gen\_lobe : np.array & \\
		\hdashline
		\_\_init\_\_(self, regular\_grid, acr\_domain, fcr\_domain, number\_acr, number\_fcr, window\_type,\\ window\_size, nfft, fs=None, method\_a=None, method\_p=None, method\_f=None) &\\
		\_gen\_uniform\_lut(self) & \\
		\_gen\_non\_uniform\_lut(self) & \\
		\_gen\_lobes\_legacy(self, i, j, acr, fcr, t, n) & \\
		\_gen\_lobe(self) & \\
		\_get\_lobe(self) & \\
		\_interpolate\_lobe(self, acr, fcr, method\_a=None, method\_p=None, method\_f = None)) & \\
		\hline
\end{tabular}} \medskip\newline
\\

The aim is to generate a LUT with a uniform or a non-uniform grid, and to generate a lobe for a given ACR/FCR couple by interpolating with existing lobes of the LUT. The user must chose the kind of interpolation he or she wants to use for magnitude, phase and frequency. Besides, he can choose the size of the LUT to build by giving the number of ACRs and FCRs.
\section{Phase Vocoder module}\label{sec:phase-vocoder-module}
\subsection{PhaseVocoder}\label{sec:phasevocoder}
\texttt{%
	\begin{tabular}{|lc|}
		\hline
		PhaseVocoder & \\
		\hline
		\hline
		\_analysis\_hop : int & \\
		\_synthesis\_hop : int & \\
		\_omega : np.array  & \\
		\_past\_analysis\_spectrum : spectrum & \\
		\_past\_synthesis\_spectrum : spectrum & \\
		\_current\_analysis\_spectrum : spectrum & \\
		current\_synthesis\_spectrum : spectrum & \\
		\hdashline
		\_\_init\_\_(self, analysis\_hop, synthesis\_hop, current\_synthesis\_spectrum) & \\
		get\_region(self, k) & \\
		get\_pv\_spectrum(self, k) & \\
		\hline
\end{tabular}} \medskip\newline
This module is not used by the mains yet. Please look up section \ref{sec:phase-vocoder} page \pageref{sec:phase-vocoder} to know what this module do. The PhaseVocoder file gathers both the Stationary Phase Vocoder and the Non-Stationary Phase
\subsection{StationaryPhaseVocoder}\label{sec:stationaryphasevocoder}
\subsection{NonStationaryPhaseVocoder}\label{sec:nonstationaryphasevocoder}

\newpage
\section*{Conclusion}
\newpage
\appendix
\section{Phase advance and propagation along the signal}
\subsection{On the first attempt at Phase Vocoder use}
In the stationary case, the Phase Vocoder is expressed in 3 equations as follow :
\begin{equation}\label{eq1}
\Delta \Phi_{k}^{u} = \angle X(t_a^u, \Omega_k) - \angle X(t_a^{u-1}, \Omega_k) - R_a \Omega_k
\end{equation}
\begin{equation}\label{eq2}
\hat{\omega_k}(t_a^u) = \Omega_k + \frac{\Delta_p \Phi_{k}^u}{R_a}
\end{equation}
\begin{equation}\label{eq3}
\angle Y(t_s^u, \Omega_k) = \angle Y(t_s^{u-1}, \Omega_k) + R_s \hat{\omega_k}(t_a^u)
\end{equation}
What (\ref{eq1}) means is that we look for the true phase shift (the analysis phase shift) during the frame $u$ and $u-1$ which is $\angle X(t_a^u, \Omega_k) - \angle X(t_a^{u-1}, \Omega_k)$ and we compute the error in phase shift, that is to say the difference between the \emph{true} phase shift and the \emph{expected} phase shift.\\
In (\ref{eq2}) we use the error in phase shift to compute the deviation in frequency $\frac{\Delta_p \Phi_{k}^u}{R_a}$ from the expected frequency $\Omega_k$ and thus compute the \emph{true} frequency at which the bin was excited between $t_a^{u-1}$ and $t_a^{u}$.\\
Finally (\ref{eq3}) assume the correct synthesis phase shift will be $R_s\hat{\omega_k}(t_a^u)$ that is the true frequency times the synthesis hop.\\
\\
The issue with such an approach in our case is that we dropped the analysis. We want to use the Phase Vocoder to \emph{create} phase shifts in our spectra, but the Phase Vocoder is in fact nothing but a fancy way to copy existing phase shifts while taking into account a different hop during analysis and synthesis. I will try and break down the issues I have into two cases.
\subsubsection{"Pure" synthesis}\label{puresynth}
We wish to synthesize a stationary or a sum of stationary sinusoid from scratch. For simplicity's sake and without loss of generality we will take the one sinusoid case.
That is to say that we want, without prior knowledge to generate $s(n)$ such as :
\begin{equation}\label{statSignal}
s(n) = \alpha \cos(2\pi\tilde{f} n + \phi)
\end{equation}
knowing only $\alpha$, $\tilde{f}$ and $\phi$.\\

We will also, to ease the process, assume that we know the application\footnote{And this this is a very strong hypothesis in the sense that it will never be true, but this is not the core issue at stake here.} ${f_{w, \tilde{f}}(\phi) : \phi \mapsto \tilde{\phi}}$ which takes into account the effect of windowing on the phase of the frame spectrum's phase\footnote{For more details on the theory, please read part \ref{part:method-overview} page \pageref{part:method-overview}}.\\ \\
The first step is then to generate a synthetic spectrum with the desired parameters. To do this we only generate a main lobe derived from the Fourier transform of the normalized window $w$ supposedly\footnote{Because no actual analysis happened} used during analysis, and place it at the right position on the spectrum. This involves to interpolate the relevant bins value if by any chance the wanted frequency $\tilde{f}$ is not exactly on a bin, that is to say if $\tilde{f} \notin \{\frac{2 k \pi}{N} \}_{k=0...N-1}$. We then multiply the generated lobe by $\frac{A}{2}$ and set the lobe phase to $\tilde{\phi} + 2\pi \tilde{f} R_a$    \footnote{This is because we wish to generate frame spaced by $R_a$ so we have to compensate the \emph{expected} phase shift by hand. In fact, in the purely stationary case, the expected phase shift is the theoretical phase shift.}. We then wished to use the phase vocoder to advance the phase (compute the needed phase shift). To get the temporal frame, we theoretically only have to compute the inverse Fourier transform of the generated spectrum.\\
In order to use the Phase Vocoder we assumed the generated spectrum to be equivalent to the analysis spectrum $X(t_a^u)$ and the antecedently phase corrected spectrum to be equivalent to the past synthesis spectrum $Y(t_a^{u-1})$.\\
At the first iteration :
\begin{itemize}
	\item $X(t_a^{u-1})$ is void because by hypothesis, nothing happened before.
	\item $X(t_a^u)$ is the freshly generated spectrum
	\item $Y(t_a^{u-1})$ is also void for the same reasons
\end{itemize}
Equation \ref{eq1} gives, for $k \in {1...N-1} \text{ s.t } X(t_a^{u}, \Omega_k) \text{ is a bin of the lobe}$ a phase shift error of $\tilde{\phi}$.\\
Then after \ref{eq2} and \ref{eq3} we obtain :
\begin{equation*}
\begin{split}
\angle Y(t_s^u, \Omega_k) & = \angle Y(t_s^{u-1}, \Omega_k) + R_s \hat{\omega_k}(t_a^u)\\
& = \angle Y(t_s^{u-1}, \Omega_k) + \frac{R_s}{R_a}\tilde{\phi} + R_s\Omega_k
\end{split}
\end{equation*}
If $R_s = R_a$ we have a perfect reconstruction of the time synthesized overlap-add test signal. However, in that case, the Phase Vocoder is perfectly irrelevant to the synthesis, indeed, since we have no \emph{actual} analysis phase, we only need to modify $R_a$ to change the length of the final signal.\\
At the following iteration, we have to update the phase of the generated spectrum to $\tilde{\phi} + 2\times2\pi \tilde{f} R_a$ instead of $\tilde{\phi} + 2\pi \tilde{f} R_a$ (as computed in (\ref{phaseAdvanceStat})), recursively, we can define the phase of the lobe the ith generated spectrum as :
\begin{equation}
\begin{cases}
\tilde{\phi}_i = \tilde{\phi}_{i-1} + 2\pi \tilde{f} R_a \\
\tilde{\phi}_0 = \tilde{\phi}
\end{cases}
\end{equation}
\subsubsection{"Parametered" synthesis}
In this case, we will not synthesize a truly stationary signal but we assume that the signal is quasi-stationary, which is to say that given a small enough analysis window, it can be considered stationary within that frame.
\begin{equation}
s(n)\cdot \mathds{1}_{[t_a^{u-1}, t_a^u]} \simeq \alpha \cos(2\pi\tilde{f} n + \phi)
\end{equation}
Note that the initial phase $\phi$ is constant from one frame to the other \emph{by definition}, indeed, a change of phase is equivalent to a sweep in frequency. Also this is more of a constrain of stability on frequency than it is on amplitude because of the nature of the overlap-add process.\\
We can assume that under the right conditions the method developed in subsection \ref{puresynth} above still holds, if we update the parameters $\tilde{f}$ and $\alpha$ in the spectrum generation.
\subsection{Theoretical phases advance}\label{theoretical_phase_advance}
For stationary signals expressed as in (\ref{statSignal}) the phase advance from one frame to the other is elementary to compute :
\begin{equation}\label{phaseAdvanceStat}
\begin{split}
\Delta \Phi_{f}^{t_a} & = \Phi_{f}^{t_a + H_a} - \Phi_{f}^{t_a}\\
& = 2\pi f (t_a + H_a) + \phi - 2\pi f t_a - \phi\\
& = 2\pi f H_a = 2\pi \tilde{f} R_a
\end{split}
\end{equation}
Where $H_a$ is the hop-size in seconds that is $H_a = \frac{R_a}{f_s}$.\\
For non stationary signal expressed as :
\begin{equation}
s(n) = (\alpha + \mu \cdot t_a) \sin(2\pi f t_a + \frac{\psi}{2} t_a^2 + \phi)
\end{equation}
The phase advance is computed in the same way :
\begin{equation}
\begin{split}
\Delta \Phi_{f}^{t_a} & = \Phi_{f}^{t_a + H_a} - \Phi_{f}^{t_a}\\
& = 2\pi f (t_a + H_a) + \frac{\psi}{2} (t_a + H_a)^2 + \phi - (2\pi f t_a + \frac{\psi}{2} t_a^2 + \phi)\\
& = 2\pi f H_a + \frac{\psi}{2}(t_a^2 + 2 t_a H_a + H_a^2) - \frac{\psi}{2} t_a^2\\
& = 2\pi f H_a + \frac{\psi}{2}(2 t_a H_a + H_a^2)\\
& = 2\pi (f + \frac{\psi}{2\pi}t_a)H_a + \frac{\psi}{2}H_a^2
\end{split}
\end{equation}
\newpage
\bibliographystyle{ieeetran}
\bibliography{biblioProjetLong}
\end{document}
